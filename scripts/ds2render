#!env python
import os
import sys
import pickle
import logging
import argparse
import textwrap
import pyhorde3d
import PIL.Image

import numpy as np


def parseCmdline():
    """Parse the command line arguments."""
    description = textwrap.dedent(f'''\
        Use Horde3D to render DS2 related assets.
    ''')

    # Create a parser and program description.
    parser = argparse.ArgumentParser(
        description=description,
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    padd = parser.add_argument

    # Add the command line options.
    padd('mode', choices=['flight', 'cubes', 'background'],
         help='Which content to render')
    padd('--skybox', action='store_true', help='Add a skybox to mimic space')
    padd('--dst-path', metavar='', type=str,
         default=os.path.join(os.getcwd(), 'img'),
         help='Where to write images')
    padd('--resolution', metavar='', type=str, default='256x256',
         help='Width x Height, eg "512x256"')
    padd('--num-images', metavar='', type=int, default=10,
         help='Number of images to render')
    padd('--num-cubes', metavar='', type=int, default=200,
         help='Number of cubes in flight scene (only useful in flight mode)')
    padd('--jpg-quality', metavar='', type=int, default=90,
         help='JPEG quality (default=90)')
    padd('--seed', metavar='', type=int, default=0,
         help='Seed value to ensure reproducible scenes')
    padd('--fov', metavar='', type=int, default=45,
         help='Field of view of camera')

    # Parse the actual arguments.
    param = parser.parse_args()

    # Unpack and sanity check the resolution string.
    try:
        res = param.resolution.split('x')
        assert len(res) == 2
        width, height = [int(_) for _ in res]
        assert width > 0 and height > 0
        param.width, param.height = width, height
        del param.resolution
    except (ValueError, AssertionError):
        print(f'Invalid resolution <{param.resolution}>')
        sys.exit()

    param.num_cubes = max(0, param.num_cubes)
    param.num_frames = max(0, param.num_images)
    return param


def getLogger(name):
    """Return a custom logger object for DS2 functionality."""
    # Return the logger object if it has handler (means we have already
    # configured it).
    logit = logging.getLogger(name)

    # Specify the logging format.
    fmt = (
        '%(asctime)s|%(levelname)s|%(pathname)s:%(lineno)d:%(funcName)s'
        ' (%(process)d)|%(message)s'
    )
    formatter = logging.Formatter(fmt)

    # Configure our own handler (will send the log messages to Relays) and
    # attach it to the logger object.
    handler = logging.StreamHandler()
    handler.setFormatter(formatter)
    logit.addHandler(handler)
    logit.setLevel(logging.DEBUG)
    return logit


class Engine(pyhorde3d.PyHorde3D):
    def __init__(self, width, height, fov=45):
        self.logit = getLogger('Horde3d')
        self.fov = fov

        # Initialise Horde.
        super().__init__(width, height)

        self.res_idx = 0
        self.frameCnt = 0

        # No lights upon startup.
        self.lights = {}
        self.models = {}
        self.resources = {}

        # Load default resources.
        self.cam = self.setupHorde()

        self.logit.info('Initialised Horde')

    def _setRenderSize(self, cam, width, height):
        assert width > 0 and height > 0

        self.h3dSetNodeParamI(cam, self.h3dCamera.ViewportXI, 0)
        self.h3dSetNodeParamI(cam, self.h3dCamera.ViewportYI, 0)
        self.h3dSetNodeParamI(cam, self.h3dCamera.ViewportWidthI, width)
        self.h3dSetNodeParamI(cam, self.h3dCamera.ViewportHeightI, height)

        # Set virtual camera parameters
        near, far = 0.1, 5000
        self.h3dSetupCameraView(cam, self.fov, width / height, near, far)
        self.h3dResizePipelineBuffers(self.resources['shader'], width, height)

    def _renderToImage(self):
        self.frameCnt += 1

        # Render the scene.
        self.h3dRender(self.cam)
        self.h3dFinalizeFrame()
        self.h3dClearOverlays()

        # Update log file, in case some
        self.h3dUtDumpMessages()

        # Query the size of the last screenshot, so that we can allocate a
        # buffer into which Horde can copy the data from the GPU. We will need
        # to allocate two buffer. The fact that we need two is an
        # implementation detail. FYI: the floating point one will hold the RGBA
        # image data (float values in [0, 1]). The C++ code will unpack the
        # RGBA data into our second RGB buffer, and convert it to uint8 in the
        # process. Some NumPy magic would have been just as efficient, and one
        # day I will fix it.
        width, height = self.h3dScreenshotDimensions()
        f32buf = np.zeros(width * height * 4, np.float32)
        img_buf = np.zeros(width * height * 3, np.uint8)

        # Request the screenshot data and unpack it into the usual
        # Height x Width x 3 format.
        assert self.h3dScreenshot(f32buf, img_buf)
        img = np.zeros((height, width, 3), np.uint8)
        img[:, :, 0] = img_buf[0::3].reshape(height, width)
        img[:, :, 1] = img_buf[1::3].reshape(height, width)
        img[:, :, 2] = img_buf[2::3].reshape(height, width)
        return img

    def setupHorde(self):
        """Load basic/shared resources, and create the basic models.

        Only basic resource like the shaders, the skybox, and the disk-like
        platform will be loaded here.

        The platform and skybox will also be added to the scene. This suffices
        to render a non-trivial scene immediately afterwards.
        """
        # Global Horde options.
        self.h3dSetOption(self.h3dOptions.LoadTextures, 1)
        self.h3dSetOption(self.h3dOptions.TexCompression, 0)
        self.h3dSetOption(self.h3dOptions.MaxAnisotropy, 4)
        self.h3dSetOption(self.h3dOptions.ShadowMapSize, 2048)
        self.h3dSetOption(self.h3dOptions.FastAnimation, 1)

        # Define the resources that we will load manually.
        rt = self.h3dResTypes
        resources = [
            ('base', rt.SceneGraph, 'models/platform/platform.scene.xml'),
            ('sky', rt.SceneGraph, 'models/skybox/skybox_ds2.scene.xml'),
            ('light', rt.Material, 'materials/light.material.xml'),
            ('shader', rt.Pipeline, 'pipelines/deferred.pipeline.xml'),
        ]
        del rt

        # Manually load the resources specified above.
        path = pyhorde3d.getResourcePath()
        self.resources.clear()
        for name, rtype, fname in resources:
            res = self.h3dAddResource(rtype, name, 0)
            self.resources[name] = res
            fname = os.path.join(path, fname)
            self.h3dLoadResource(res, open(fname, 'rb').read())

        # Load all those resources whose name denotes a path (that includes
        # shaders, light materials, etc.)
        if not self.h3dUtLoadResourcesFromDisk(path):
            self.logit.error('Could not load main resources')
        else:
            self.logit.info('Resources loaded')
        del path

        # Add the camera. Note: there will only be a single camera.
        root = self.h3dRootNode
        camera = self.h3dAddCameraNode(root, 'Camera', self.resources['shader'])

        # Add the skybox to the scene.
        self.models['skybox'] = self.h3dAddNode(root, self.resources['sky'])
        self.h3dSetNodeFlags(
            self.models['skybox'], self.h3dNodeFlags.NoCastShadow, True)

        # Update Horde's log file.
        self.h3dUtDumpMessages()
        return camera

    def loadDefaultResources(self):
        """ Load the resources for 10 cubes.

        Each cube has the same geometry, but a different texture, one for each
        digit [0-9]. To respective resource names are eg 'cube_5'.

        NOTE: this is a convenience method to load the resources for the
        platform and all cubes.

        Returns:
            dict: {cube_nr: handle}, where 'cube_nr' is an integer in [0, 9].
        """
        rt = self.h3dResTypes
        path = os.path.join(pyhorde3d.getResourcePath(), 'models', 'cube')

        fname = os.path.join(path, 'cube.scene.xml')
        scn_cube_xml_template = open(fname, 'r').read()
        fname = os.path.join(path, 'cube.material.xml')
        mat_cube_xml_template = open(fname, 'r').read()
        del fname

        ret = {}
        for i in range(10):
            self.res_idx += 1
            res_name = f'cube_{i}'
            mat_name = f'mat_cube_{i}'
            scn_cube_xml = scn_cube_xml_template.replace(
                'material="cube.material.xml"', f'material="{mat_name}"')
            res = self.h3dAddResource(rt.SceneGraph, res_name, 0)
            self.h3dLoadResource(res, scn_cube_xml.encode('utf8'))
            self.resources[self.res_idx] = res
            ret[i] = res
            del res

            mat_cube_xml = mat_cube_xml_template.replace('0.jpg', f'{i}.jpg')
            res = self.h3dAddResource(rt.Material, mat_name, 0)
            self.h3dLoadResource(res, mat_cube_xml.encode('utf8'))

        # Add the platform resource.
        ret['base'] = self.resources['base']

        if not self.h3dUtLoadResourcesFromDisk(path):
            self.logit.error('Could not load cube resources')
            return {}

        self.logit.info('Loaded all cube resources')
        self.h3dUtDumpMessages()
        return ret

    def addNode(self, resource, parent=None):
        parent = parent or self.h3dRootNode
        return self.h3dAddNode(parent, resource)

    def addLight(self):
        self.res_idx += 1
        root = self.h3dRootNode

        lname = f'Light{self.res_idx}'
        res = self.resources['light']
        light = self.h3dAddLightNode(root, lname, res, "LIGHTING", "SHADOWMAP")
        self.h3dSetNodeParamF(light, self.h3dLight.RadiusF, 0, 4000)
        self.h3dSetNodeParamF(light, self.h3dLight.FovF, 0, 90)
        self.h3dSetNodeParamI(light, self.h3dLight.ShadowMapCountI, 3)
        self.h3dSetNodeParamF(light, self.h3dLight.ShadowSplitLambdaF, 0, 0.9)
        self.h3dSetNodeParamF(light, self.h3dLight.ShadowMapBiasF, 0, 0.001)
        self.h3dSetNodeParamF(light, self.h3dLight.ColorF3, 0, 1.0)
        self.h3dSetNodeParamF(light, self.h3dLight.ColorF3, 1, 1.0)
        self.h3dSetNodeParamF(light, self.h3dLight.ColorF3, 2, 1.0)

        self.lights[self.res_idx] = light
        return light

    def setNodeTransMat(self, node, tm):
        assert isinstance(tm, bytes)
        assert len(tm) == 16 * 4
        return self.h3dSetNodeTransMat(node, np.fromstring(tm, np.float32))

    def setNodeTransPes(self, node, pos, euler, scale):
        assert len(pos) == len(euler) == len(scale) == 3
        self.h3dSetNodeTransform(node, *pos, *euler, *scale)

    def renderScene(self, cmat, width, height, skybox=True):
        assert isinstance(cmat, bytes)

        assert width > 0 and height > 0
        self._setRenderSize(self.cam, width, height)

        # Center the SkyBox at the camera. The scale of the skybox is related
        # to the `far` plane of the camera; it must be less than `far` /
        # sqrt(3) to be fully visible.
        if skybox:
            pos = np.fromstring(cmat, np.float32).tolist()
            pos = pos[-4:-1]
            scale = 3 * [int(0.9 * 5000 / np.sqrt(3))]
        else:
            pos = scale = (0, 0, 0)
        self.h3dSetNodeTransform(self.models['skybox'], *pos, 0, 0, 0, *scale)
        del pos, scale

        # Update the camera position, then render the scene and return the image.
        self.h3dSetNodeTransMat(self.cam, np.fromstring(cmat, np.float32))
        return self._renderToImage()


def camVectorsToCamMatrix(right, up, pos):
    if np.inner(right, up) > 1E-3:
        return None

    # Compute forward vector and assemble the rotation matrix.
    forward = np.cross(right, up)
    rot = np.vstack([right, up, forward])

    ret = np.eye(4)
    ret[:3, :3] = rot
    ret[3, :3] = pos
    ret = ret.astype(np.float32)
    return ret.flatten('C').tobytes()


def projectCubePositions(param, cmat, labels, cube_pos):
    fov = param.fov / 2
    fov = np.tan(fov * np.pi / 180)
    aspect_ratio = param.width / param.height

    cmat = np.fromstring(cmat, np.float32).reshape(4, 4)
    assert cmat.shape == (4, 4)

    tmp = (cube_pos - cmat[3, :3]) @ cmat[:3, :3].T
    x, y, z = tmp[:, 0], tmp[:, 1], tmp[:, 2]
    z = -z
    del tmp, cmat

    idx = np.nonzero(z > 0.1)
    x, y, z, labels = x[idx], y[idx], z[idx], labels[idx]

    x = x / (z * fov * aspect_ratio)
    y = y / (z * fov)

    bound = 1.05
    cond_x = (-bound < x) & (x < bound)
    cond_y = (-bound < y) & (y < bound)
    idx = np.nonzero(cond_x & cond_y)
    x, y, z, labels = x[idx], y[idx], z[idx], labels[idx]
    del bound, cond_x, cond_y, idx

    x = (x + 1) / 2
    y = 1 - (y + 1) / 2

    pos = np.vstack([x, y, z]).T
    bb_hlen = np.vstack([4 / (aspect_ratio * z), 4 / z]).T
    return pos, labels, bb_hlen


def renderGroundTruthCubes(param):
    h = Engine(param.width, param.height, param.fov)
    default_resources = h.loadDefaultResources()

    # Add a default light. Then place it far away to mimic a sun.
    lname = h.addLight()
    pos = 2000 * np.array([0, 1, 1], np.float32)
    tm = np.eye(4)
    tm[2, :3] = pos / np.linalg.norm(pos)
    tm[3, :3] = pos
    h.setNodeTransMat(lname, tm.flatten().astype(np.float32).tobytes())
    del lname, pos, tm

    # Make the platform invisible.
    dst_path = os.path.join(param.dst_path, 'cubes')
    h.h3dSetNodeTransform(default_resources['base'], 0, 0, 0, 0, 0, 0, 0, 0, 0)

    # Add all 10 cubes and set their size to zero to make them invisible.
    nodes = {}
    for i in range(10):
        nodes[i] = h.addNode(default_resources[i])
        h.setNodeTransPes(nodes[i], [0, 0, 0], [0, 0, 0], [0, 0, 0])

    # Create a random orientation for the cube, a random position for the
    # camera (but always pointed to the center), render each of the
    # ten cube, and save each in their own file. Repeat this process as many
    # times as was specified in the --num-images argument.
    for i in range(param.num_images):
        # Compute a random position on the unit sphere.
        phi, theta = np.random.uniform(-1, 1, 2) * [2 * np.pi, np.pi]
        pos = np.array([
            np.sin(theta) * np.cos(phi),
            np.sin(theta) * np.sin(phi),
            np.cos(theta),
        ])

        # Compute a random right/up vector that is orthogonal to the position
        # vector, since that one specifies the forward vector.
        tmp = np.random.uniform(-1, 1, 3)
        tmp = tmp / np.linalg.norm(tmp)
        right = tmp - np.inner(tmp, pos) * pos
        right = right / np.linalg.norm(right)
        up = -np.cross(right, pos)

        # Convert right/up/pos into a camera matrix. Also, adjust the camera
        # distance to move it as close as possible without clipping the cube in
        # the rendered image. This is an empirical value.
        distance = 4.5
        cmat = camVectorsToCamMatrix(right=right, up=up, pos=distance * pos)
        tmp = np.fromstring(cmat, np.float32).reshape(4, 4)[:3, :3]
        assert cmat is not None
        del phi, theta, pos, right, up, distance, tmp

        # Compute random orientation of cube. Every cube will have the same
        # orientation.
        u = np.linalg.svd(np.random.uniform(-1, 1, size=(3, 3)))[0]
        tm = camVectorsToCamMatrix(right=u[0], up=u[1], pos=[0, 0, 0])
        assert tm is not None
        del u

        # Render each cube into a file.
        for j in range(10):
            dst_path = os.path.join(param.dst_path, f'{j:02d}')
            os.makedirs(dst_path, exist_ok=True)

            # Apply the transform to the current cube.
            h.setNodeTransMat(nodes[j], tm)

            # Render the scene to an image.
            img = h.renderScene(cmat, param.width, param.height, skybox=False)
            img = PIL.Image.fromarray(np.flipud(img))
            fname = os.path.join(dst_path, f'{i:04d}.jpg')
            img.save(fname, 'jpeg', quality=param.jpg_quality)

            # Set the scale to zero to make the cube invisible, because we only
            # want to see one cube in each image, not all 10.
            h.setNodeTransPes(nodes[j], [0, 0, 0], [0, 0, 0], [0, 0, 0])
            del j, img
        del tm
    print(f'Saved pure cube images to <{dst_path}>')


def renderGroundTruthBackground(param):
    h = Engine(param.width, param.height, param.fov)
    default_resources = h.loadDefaultResources()

    # Ensure the target directory exists.
    dst_path = os.path.join(param.dst_path, 'background')
    os.makedirs(dst_path, exist_ok=True)

    # Add a default light. Then place it far away to mimic a sun.
    lname = h.addLight()
    pos = 2000 * np.array([0, 1, 1], np.float32)
    tm = np.eye(4)
    tm[2, :3] = pos / np.linalg.norm(pos)
    tm[3, :3] = pos
    h.setNodeTransMat(lname, tm.flatten().astype(np.float32).tobytes())
    del lname, pos, tm

    # Add the platform.
    platform = h.addNode(default_resources['base'])

    # Render the empty scenes from several random angles/positions.
    for i in range(param.num_images):
        pos = 50 * np.random.uniform(-1, 1, 3)
        euler = 180 * np.random.uniform(-1, 1, 3)
        scale = 1 * np.random.uniform(0, 1, 3)
        h.setNodeTransPes(platform, pos.tolist(), euler.tolist(), scale.tolist())
        del pos, euler, scale

        # Compute random right/up/position vector for camera.
        u, _, _ = np.linalg.svd(np.random.uniform(-1, 1, size=(3, 3)))
        pos = 100 * np.random.uniform(-1, 1, 3)
        cmat = camVectorsToCamMatrix(right=u[0], up=u[1], pos=pos)
        assert cmat is not None
        del u

        # Render the scene and save the image.
        img = h.renderScene(cmat, param.width, param.height, skybox=True)
        img = PIL.Image.fromarray(np.flipud(img))
        fname = os.path.join(dst_path, f'{i:04d}.jpg')
        img.save(fname, 'jpeg', quality=param.jpg_quality)
    print(f'Saved background images to <{dst_path}>')


def renderFlightPath(param):
    dst_path = os.path.join(param.dst_path, 'flightpath')
    os.makedirs(dst_path, exist_ok=True)

    h = Engine(param.width, param.height, param.fov)
    default_resources = h.loadDefaultResources()

    # Add a default light. Then place it far away to mimic a sun.
    lname = h.addLight()
    pos = 2000 * np.array([0, 1, 1], np.float32)
    tm = np.eye(4)
    tm[2, :3] = pos / np.linalg.norm(pos)
    tm[3, :3] = pos
    h.setNodeTransMat(lname, tm.flatten().astype(np.float32).tobytes())
    del lname, pos, tm

    node = h.addNode(default_resources['base'])
    h.setNodeTransPes(node, [0, -21, 0], [0, 0, 0], [1, .2, 1])
    del node

    # Initialise the random generator to ensure reproducible results.
    np.random.seed(param.seed)

    # Draw the number of each cube at random.
    cube_num = np.random.choice(np.arange(10), param.num_cubes)

    # Create random positions and orientations for each cube.
    cube_pos = 50 * np.random.uniform(-1, 1, size=(param.num_cubes, 3))
    cube_rot = 180 * np.random.uniform(-1, 1, size=(param.num_cubes, 3))

    # Each cube has the same size in the scene.
    scale = 2 * np.ones(3)

    # Create a flight path, that is, create the camera- position and vectors.
    # To ensure a "smooth" path that also connects the end to the beginning, we
    # will use trigonometric functions only.
    cam_mat = []
    for phi in np.linspace(0, 2 * np.pi, param.num_frames):
        pos = (30 * np.cos(phi), 20 * np.sin(phi), 30 * np.sin(phi))
        right = np.array([np.cos(3 * phi), 0, np.sin(3 * phi)])
        cmat = camVectorsToCamMatrix(right=right, up=[0, 1, 0], pos=pos)
        cam_mat.append(cmat)
        del phi, pos, right, cmat

    # Add each cube to the scene and set its transform.
    for idx, (pos, rot, num) in enumerate(zip(cube_pos, cube_rot, cube_num)):
        node = h.addNode(default_resources[num])
        h.setNodeTransPes(node, pos, rot, scale)

    # Compile meta information for the scene and pickle it to a file.
    meta = {
        'seed': param.seed,
        'fov': param.fov,
        'width': param.width,
        'height': param.height,
        'num_frame': param.num_frames,
        'num_cubes': param.num_cubes,
        'cam_mat': cam_mat,
        'cube_pos': cube_pos,
        'cube_rot': cube_rot,
        'cube_num': cube_num,
        'projected': {},
    }

    # Move the camera through the scene and save each frame as a JPG file.
    for idx, cmat in enumerate(cam_mat):
        fname = f'{idx:04d}.jpg'
        img = h.renderScene(cmat, param.width, param.height)
        img = PIL.Image.fromarray(np.flipud(img))
        img.save(os.path.join(dst_path, fname), 'jpeg', quality=param.jpg_quality)
        pos, labels, bb_hlen = projectCubePositions(param, cmat, cube_num, cube_pos)
        meta['projected'][fname] = {'pos': pos, 'labels': labels, 'hlen': bb_hlen}

    print(f'Saved flight path images to <{dst_path}>')

    fname = os.path.join(dst_path, 'meta.pickle')
    pickle.dump(meta, open(fname, 'wb'))


def main():
    # Ensure the image sequence is repeatable.
    np.random.seed(0)

    param = parseCmdline()
    if param.mode == 'flight':
        renderFlightPath(param)
    elif param.mode == 'cubes':
        renderGroundTruthCubes(param)
    elif param.mode == 'background':
        renderGroundTruthBackground(param)
    elif param:
        assert False, f'Unknown mode <{param.mode}>'


if __name__ == '__main__':
    main()
